<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Evolved</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        :root {
            --primary-color: #00ffaa;
            --secondary-color: #0099ff;
            --dark-color: #0a192f;
            --light-color: #ccd6f6;
            --danger-color: #ff5555;
            --warning-color: #ffcc00;
            --success-color: #00cc66;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Orbitron', sans-serif;
            background-color: var(--dark-color);
            color: var(--light-color);
            overflow: hidden;
            user-select: none;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            background-color: rgba(10, 25, 47, 0.9);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.7);
            position: relative;
            z-index: 20;
            border-bottom: 1px solid var(--primary-color);
        }
        
        #game-title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
        }
        
        #game-info {
            display: flex;
            gap: 25px;
            font-size: 16px;
        }
        
        .info-box {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 170, 0.2);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .info-box span {
            color: var(--primary-color);
            font-weight: bold;
        }
        
        #wave-timer {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--danger-color), #ff0000);
            padding: 8px 25px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 0 15px rgba(255, 85, 85, 0.5);
            display: none;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }
        
        #game-board {
            position: relative;
            flex-grow: 1;
            background-color: #0a1426;
            overflow: hidden;
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(0, 255, 170, 0.1) 1px, transparent 0);
            background-size: 40px 40px;
           
        }
        
        #base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, var(--primary-color), #00cc99);
            border-radius: 50%;
            border: 5px solid var(--light-color);
            box-shadow: 0 0 20px var(--primary-color);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            color: var(--dark-color);
            z-index: 10;
            transition: all 0.3s;
        }
        
        #base:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 30px var(--primary-color);
        }
        
        .building {
            position: absolute;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px #000;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 5;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        .building:hover {
            transform: scale(1.1);
            z-index: 15;
        }
        
        /* Estilos √∫nicos para cada constru√ß√£o */
        .miner {
            background: linear-gradient(135deg, #2b7a0b, #5bb318);
            border: 2px solid #a8ff78;
            box-shadow: 0 0 15px rgba(43, 122, 11, 0.6);
            clip-path: polygon(50% 0%, 80% 20%, 100% 50%, 80% 80%, 50% 100%, 20% 80%, 0% 50%, 20% 20%);
        }
        
        .cannon {
            background: linear-gradient(135deg, #7d5a50, #b4846c);
            border: 2px solid #ffb48f;
            box-shadow: 0 0 15px rgba(125, 90, 80, 0.6);
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
        }
        
        .wall {
            background: linear-gradient(135deg, #555555, #888888);
            border: 2px solid #cccccc;
            box-shadow: 0 0 15px rgba(85, 85, 85, 0.6);
            clip-path: polygon(0% 0%, 100% 0%, 100% 30%, 70% 50%, 100% 70%, 100% 100%, 0% 100%, 0% 70%, 30% 50%, 0% 30%);
        }
        
        .laser {
            background: linear-gradient(135deg, #3a0ca3, #7209b7);
            border: 2px solid #f72585;
            box-shadow: 0 0 20px rgba(58, 12, 163, 0.7);
            clip-path: circle(50% at 50% 50%);
        }
        
        .missile {
            background: linear-gradient(135deg, #ff5e00, #ff2900);
            border: 2px solid #ffcc00;
            box-shadow: 0 0 20px rgba(255, 94, 0, 0.7);
            clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
        }
        
        .slow-tower {
            background: linear-gradient(135deg, #00b4d8, #0077b6);
            border: 2px solid #90e0ef;
            box-shadow: 0 0 20px rgba(0, 180, 216, 0.7);
            clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);
        }
        
        .barracks {
            background: linear-gradient(135deg, #6a040f, #9d0208);
            border: 2px solid #dc2f02;
            box-shadow: 0 0 20px rgba(106, 4, 15, 0.7);
            clip-path: polygon(0% 0%, 100% 0%, 100% 70%, 50% 100%, 0% 70%);
        }
        
        .building-level {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 11px;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }
        
        .health-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background-color: rgba(255, 0, 0, 0.3);
            border-radius: 0 0 5px 5px;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc66);
            border-radius: 0 0 5px 5px;
            transition: width 0.3s;
        }
        
        .mineral {
            position: absolute;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #ffd700, #daa520);
            border-radius: 50%;
            border: 2px solid #ffcc00;
            z-index: 2;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0px); }
        }
        
        .enemy {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            z-index: 4;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            animation: pulseEnemy 2s infinite;
        }
        
        @keyframes pulseEnemy {
            0% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
            50% { box-shadow: 0 0 15px rgba(255, 0, 0, 0.8); }
            100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
        }
        
        .enemy-type1 {
            background: radial-gradient(circle at 30% 30%, #ff5555, #cc0000);
            border: 2px solid #ff0000;
        }
        
        .enemy-type2 {
            background: radial-gradient(circle at 30% 30%, #ff9966, #cc6600);
            border: 2px solid #ff6600;
        }
        
        .enemy-type3 {
            background: radial-gradient(circle at 30% 30%, #aa55ff, #6600cc);
            border: 2px solid #9900ff;
        }
        
        .enemy-type4 {
            background: radial-gradient(circle at 30% 30%, #00aa88, #008866);
            border: 2px solid #00ffcc;
        }
        
        .enemy-type5 {
            background: radial-gradient(circle at 30% 30%, #ff00aa, #cc0088);
            border: 2px solid #ff66cc;
        }
        
        .enemy-health {
            position: absolute;
            top: -12px;
            left: 0;
            width: 100%;
            height: 4px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
        }
        
        .enemy-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc66);
            border-radius: 2px;
            transition: width 0.3s;
        }
        
        .projectile {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--warning-color);
            border-radius: 50%;
            z-index: 3;
            box-shadow: 0 0 10px var(--warning-color);
        }
        
        .laser-beam {
            position: absolute;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.8), rgba(0, 200, 255, 0.8));
            z-index: 3;
            opacity: 0.9;
            filter: blur(1px);
        }
        
        .missile-trail {
            position: absolute;
            background: linear-gradient(90deg, rgba(255, 100, 0, 0.8), rgba(255, 200, 0, 0.8));
            z-index: 3;
            opacity: 0.7;
            filter: blur(1px);
        }
        
        .slow-field {
            position: absolute;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 180, 216, 0.3), transparent 70%);
            z-index: 2;
        }
        
        #build-menu {
            background-color: rgba(10, 25, 47, 0.9);
            padding: 15px;
            display: flex;
            justify-content: center;
            gap: 25px;
            border-top: 1px solid var(--primary-color);
            z-index: 20;
            overflow-x: auto;
        }
        
        .build-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            width: 110px;
            min-width: 110px;
            border: 1px solid rgba(0, 255, 170, 0.3);
        }
        
        .build-option:hover {
            transform: scale(1.05);
            background-color: rgba(0, 0, 0, 0.5);
            border-color: var(--primary-color);
        }
        
        .build-option.selected {
            background-color: rgba(0, 255, 170, 0.2);
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.5);
        }
        
        .build-option.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .build-icon {
            width: 50px;
            height: 50px;
            margin-bottom: 8px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(0, 255, 170, 0.3);
        }
        
        .build-name {
            font-size: 14px;
            margin-bottom: 5px;
            color: var(--light-color);
        }
        
        .build-cost {
            font-size: 12px;
            color: var(--warning-color);
        }
        
        .build-limit {
            font-size: 11px;
            color: var(--primary-color);
            margin-top: 3px;
        }
        
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }
        
        #game-over h1 {
            font-size: 48px;
            color: var(--danger-color);
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 85, 85, 0.7);
            animation: gameOverPulse 1.5s infinite;
        }
        
        @keyframes gameOverPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #game-over p {
            font-size: 20px;
            margin-bottom: 30px;
            color: var(--light-color);
        }
        
        #game-over span {
            color: var(--primary-color);
            font-weight: bold;
        }
        
        #restart-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--dark-color);
            border: none;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.5);
        }
        
        #restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.8);
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(10, 25, 47, 0.95);
            color: var(--light-color);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
            max-width: 250px;
            display: none;
            border: 1px solid var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 255, 170, 0.3);
        }
        
        .tooltip h3 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            font-size: 16px;
            border-bottom: 1px solid var(--primary-color);
            padding-bottom: 5px;
        }
        
        .tooltip p {
            margin: 5px 0;
        }
        
        .tooltip span {
            color: var(--primary-color);
            font-weight: bold;
        }
        
        #base-upgrade {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: var(--dark-color);
            border: none;
            border-radius: 20px;
            padding: 5px 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: none;
            z-index: 11;
            box-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }
        
        #base:hover #base-upgrade {
            display: block;
        }
        
        .upgrade-indicator {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--primary-color);
            color: var(--dark-color);
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 10px;
            display: none;
            animation: bounce 0.5s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateX(-50%) translateY(0); }
            to { transform: translateX(-50%) translateY(-5px); }
        }
        
        .building:hover .upgrade-indicator {
            display: block;
        }
        
        /* Efeitos sonoros (ocultos) */
        .audio-element {
            display: none;
        }
        
        /* Scrollbar personalizada */
        #build-menu::-webkit-scrollbar {
            height: 8px;
        }
        
        #build-menu::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }
        
        #build-menu::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="header">
            <div id="game-title">TOWER DEFENSE </div>
            <div id="game-info">
                <div class="info-box">Wave: <span id="wave-display">1</span></div>
                <div class="info-box">Diamantes: <span id="money-display">100</span></div>
                <div class="info-box">Base HP: <span id="base-hp">700</span>/700</div>
                <div class="info-box">Base Level: <span id="base-level">1</span></div>
            </div>
            <div id="wave-timer">Pr√≥xima Wave: <span id="timer-display">30</span>s</div>
        </div>
        
        <div id="game-board">
            <div id="base">
                BASE
                <button id="base-upgrade">Upgrade</button>
            </div>
            
            <div id="game-over">
                <h1>GAME OVER</h1>
                <p>Sua base foi destru√≠da na wave <span id="final-wave">1</span></p>
                <button id="restart-btn">Reiniciar</button>
            </div>
        </div>
        
        <div id="build-menu">
            <div class="build-option" data-type="miner" data-cost="25">
                <div class="build-icon">‚õèÔ∏è</div>
                <div class="build-name">Mineradora</div>
                <div class="build-cost">Custo: 25</div>
                <div class="build-limit">Limite: <span id="miner-limit">3/3</span></div>
            </div>
            <div class="build-option" data-type="cannon" data-cost="110">
                <div class="build-icon">üí£</div>
                <div class="build-name">Canh√£o</div>
                <div class="build-cost">Custo: 110</div>
                <div class="build-limit">Limite: <span id="cannon-limit">2/2</span></div>
            </div>
            <div class="build-option" data-type="wall" data-cost="15">
                <div class="build-icon">üß±</div>
                <div class="build-name">Muro</div>
                <div class="build-cost">Custo: 15</div>
                <div class="build-limit">Limite: <span id="wall-limit">5/5</span></div>
            </div>
            <div class="build-option disabled" data-type="laser" data-cost="750">
                <div class="build-icon">‚ö°</div>
                <div class="build-name">Torre Laser</div>
                <div class="build-cost">Custo: 750</div>
                <div class="build-limit">Dispon√≠vel no level 7</div>
            </div>
            <div class="build-option disabled" data-type="missile" data-cost="500">
                <div class="build-icon">üöÄ</div>
                <div class="build-name">Lan√ßador</div>
                <div class="build-cost">Custo: 500</div>
                <div class="build-limit">Dispon√≠vel no level 10</div>
            </div>
            <div class="build-option disabled" data-type="slow-tower" data-cost="300">
                <div class="build-icon">‚ùÑÔ∏è</div>
                <div class="build-name">Torre de Gelo</div>
                <div class="build-cost">Custo: 300</div>
                <div class="build-limit">Dispon√≠vel no level 15</div>
            </div>
            <div class="build-option disabled" data-type="barracks" data-cost="1000">
                <div class="build-icon">üè∞</div>
                <div class="build-name">Quartel</div>
                <div class="build-cost">Custo: 1000</div>
                <div class="build-limit">Dispon√≠vel no level 100</div>
            </div>
        </div>
        
        <div class="tooltip" id="tooltip"></div>

        <!-- Efeitos sonoros -->
        <audio id="build-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-positive-interface-beep-221.mp3"></audio>
        <audio id="upgrade-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-unlock-game-notification-253.mp3"></audio>
        <audio id="attack-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-short-laser-gun-shot-1670.mp3"></audio>
        <audio id="laser-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-laser-shot-1681.mp3"></audio>
        <audio id="missile-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-explosion-impact-1684.mp3"></audio>
        <audio id="slow-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-ice-freeze-2009.mp3"></audio>
        <audio id="barracks-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-horn-of-war-1714.mp3"></audio>
        <audio id="enemy-death-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-game-explosion-2759.mp3"></audio>
        <audio id="game-over-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-retro-arcade-lose-2027.mp3"></audio>
        <audio id="base-upgrade-sound" class="audio-element" src="https://assets.mixkit.co/sfx/preview/mixkit-achievement-bell-600.mp3"></audio>
    </div>

    <script>
        // Game state
        const gameState = {
            wave: 0,
            money: 100,
            baseHP: 700,
            maxBaseHP: 700,
            baseLevel: 1,
            baseUpgradeCost: 1800,
            gameOver: false,
            preparationTime: 30,
            isPreparationPhase: true,
            selectedBuilding: null,
            buildings: [],
            enemies: [],
            minerals: [],
            projectiles: [],
            laserBeams: [],
            missileTrails: [],
            slowFields: [],
            buildingLimits: {
                miner: { current: 0, max: 3 },
                cannon: { current: 0, max: 2 },
                wall: { current: 0, max: 5 },
                laser: { current: 0, max: 0 },
                missile: { current: 0, max: 0 },
                'slow-tower': { current: 0, max: 0 },
                barracks: { current: 0, max: 0 }
            },
            enemySpawnPoints: [
                { x: 0, y: 0 },
                { x: 0, y: 0.5 },
                { x: 0, y: 1 },
                { x: 0.5, y: 0 },
                { x: 0.5, y: 1 },
                { x: 1, y: 0 },
                { x: 1, y: 0.5 },
                { x: 1, y: 1 }
            ],
            buildingStats: {
                miner: {
                    name: "Mineradora",
                    cost: 25,
                    hp: 100,
                    baseProduction: 11,
                    productionMultiplier: 1.4, 
                    upgradeCost: 80,
                    upgradeCostMultiplier: 1.6,
                    color: "#2b7a0b",
                    size: 40,
                    icon: "‚õèÔ∏è"
                },
                cannon: {
                    name: "Canh√£o",
                    cost: 110,
                    hp: 250,
                    baseDamage: 25,
                    damageMultiplier: 1.3,
                    baseAttackSpeed: 1.5,
                    attackSpeedMultiplier: 1.05,
                    range: 200,
                    rangeMultiplier: 1.4,
                    upgradeCost: 110,
                    upgradeCostMultiplier: 1.3,
                    color: "#7d5a50",
                    size: 40,
                    icon: "üí£"
                },
                wall: {
                    name: "Muro",
                    cost: 15,
                    hp: 900,
                    hpMultiplier: 1.2,
                    upgradeCost: 15,
                    upgradeCostMultiplier: 1.3,
                    color: "#555555",
                    size: 40,
                    icon: "üß±"
                },
                laser: {
                    name: "Torre Laser",
                    cost: 750,
                    hp: 300,
                    baseDamage: 30,
                    damageMultiplier: 1.2,
                    baseAttackSpeed: 3,
                    attackSpeedMultiplier: 1.05,
                    range: 250,
                    stunDuration: 0.5,
                    chainTargets: 5,
                    upgradeCost: 750,
                    upgradeCostMultiplier: 1.3,
                    color: "#3a0ca3",
                    size: 40,
                    icon: "‚ö°"
                },
                missile: {
                    name: "Lan√ßador de M√≠sseis",
                    cost: 500,
                    hp: 350,
                    baseDamage: 50,
                    damageMultiplier: 1.25,
                    baseAttackSpeed: 3,
                    attackSpeedMultiplier: 1.03,
                    range: 300,
                    splashRadius: 60,
                    upgradeCost: 500,
                    upgradeCostMultiplier: 1.4,
                    color: "#ff5e00",
                    size: 45,
                    icon: "üöÄ"
                },
                'slow-tower': {
                    name: "Torre de Gelo",
                    cost: 300,
                    hp: 100,
                    slowAmount: 0.3, 
                    slowRadius: 150,
                    duration: 3,
                    upgradeCost: 600,
                    upgradeCostMultiplier: 1.3,
                    color: "#00b4d8",
                    size: 40,
                    icon: "‚ùÑÔ∏è"
                },
                barracks: {
                    name: "Quartel",
                    cost: 1000,
                    hp: 1000,
                    spawnRate: 10, 
                    spawnAmount: 1,
                    unitDamage: 5,
                    unitHP: 100,
                    upgradeCost: 1000,
                    upgradeCostMultiplier: 1.5,
                    color: "#6a040f",
                    size: 50,
                    icon: "üè∞",
                    lastSpawnTime: 0
                }
            },
            enemyStats: {
                baseHP: 55,
                hpMultiplier: 1.6,
                hpIncreaseWaveInterval: 3,
                speed: 70,
                damage: 80,
                types: [
                    { color: "#ff5555", border: "#cc0000", class: "enemy-type1" },
                    { color: "#ff9966", border: "#cc6600", class: "enemy-type2" },
                    { color: "#aa55ff", border: "#6600cc", class: "enemy-type3" },
                    { color: "#00aa88", border: "#008866", class: "enemy-type4" },
                    { color: "#ff00aa", border: "#cc0088", class: "enemy-type5" }
                ]
            },
            sounds: {
                build: document.getElementById('build-sound'),
                upgrade: document.getElementById('upgrade-sound'),
                attack: document.getElementById('attack-sound'),
                laser: document.getElementById('laser-sound'),
                missile: document.getElementById('missile-sound'),
                slow: document.getElementById('slow-sound'),
                barracks: document.getElementById('barracks-sound'),
                enemyDeath: document.getElementById('enemy-death-sound'),
                gameOver: document.getElementById('game-over-sound'),
                baseUpgrade: document.getElementById('base-upgrade-sound')
            }
        };

        // DOM elements
        const elements = {
            gameBoard: document.getElementById('game-board'),
            base: document.getElementById('base'),
            baseUpgradeBtn: document.getElementById('base-upgrade'),
            waveDisplay: document.getElementById('wave-display'),
            moneyDisplay: document.getElementById('money-display'),
            baseHpDisplay: document.getElementById('base-hp'),
            baseLevelDisplay: document.getElementById('base-level'),
            waveTimer: document.getElementById('wave-timer'),
            timerDisplay: document.getElementById('timer-display'),
            gameOverScreen: document.getElementById('game-over'),
            finalWaveDisplay: document.getElementById('final-wave'),
            restartBtn: document.getElementById('restart-btn'),
            buildOptions: document.querySelectorAll('.build-option'),
            tooltip: document.getElementById('tooltip'),
            minerLimit: document.getElementById('miner-limit'),
            cannonLimit: document.getElementById('cannon-limit'),
            wallLimit: document.getElementById('wall-limit'),
            laserLimit: document.getElementById('laser-limit'),
            missileLimit: document.getElementById('missile-limit'),
            slowTowerLimit: document.getElementById('slow-tower-limit'),
            barracksLimit: document.getElementById('barracks-limit')
        };

        // Game initialization
        function initGame() {
            gameState.wave = 0;
            gameState.money = 100;
            gameState.baseHP = gameState.maxBaseHP;
            gameState.baseLevel = 1;
            gameState.baseUpgradeCost = 1800;
            gameState.gameOver = false;
            gameState.isPreparationPhase = true;
            gameState.buildings = [];
            gameState.enemies = [];
            gameState.minerals = [];
            gameState.projectiles = [];
            gameState.laserBeams = [];
            gameState.missileTrails = [];
            gameState.slowFields = [];
            
            // Reset building limits
            gameState.buildingLimits = {
                miner: { current: 0, max: 3 },
                cannon: { current: 0, max: 2 },
                wall: { current: 0, max: 5 },
                laser: { current: 0, max: 0 },
                missile: { current: 0, max: 0 },
                'slow-tower': { current: 0, max: 0 },
                barracks: { current: 0, max: 0 }
            };
            
            // Update building limits display
            updateBuildingLimitsDisplay();
            
            // Clear the game board
            document.querySelectorAll('.building, .enemy, .mineral, .projectile, .laser-beam, .missile-trail, .slow-field').forEach(el => el.remove());
            
            // Update displays
            updateDisplays();
            
            // Start preparation phase
            startPreparationPhase();
            
            // Spawn some initial minerals
            spawnMinerals(15);
            
            // Hide game over screen
            elements.gameOverScreen.style.display = 'none';
            elements.waveTimer.style.display = 'none';
            
            // Disable buildings initially
            document.querySelector('.build-option[data-type="laser"]').classList.add('disabled');
            document.querySelector('.build-option[data-type="missile"]').classList.add('disabled');
            document.querySelector('.build-option[data-type="slow-tower"]').classList.add('disabled');
            document.querySelector('.build-option[data-type="barracks"]').classList.add('disabled');
        }

        // Update all game displays
        function updateDisplays() {
            elements.waveDisplay.textContent = gameState.wave;
            elements.moneyDisplay.textContent = gameState.money;
            elements.baseHpDisplay.textContent = gameState.baseHP;
            elements.baseLevelDisplay.textContent = gameState.baseLevel;
        }

        // Update building limits display
        function updateBuildingLimitsDisplay() {
            elements.minerLimit.textContent = `${gameState.buildingLimits.miner.current}/${gameState.buildingLimits.miner.max}`;
            elements.cannonLimit.textContent = `${gameState.buildingLimits.cannon.current}/${gameState.buildingLimits.cannon.max}`;
            elements.wallLimit.textContent = `${gameState.buildingLimits.wall.current}/${gameState.buildingLimits.wall.max}`;
            
            // Update limits for other buildings if they exist in the DOM
            if (elements.laserLimit) {
                elements.laserLimit.textContent = `${gameState.buildingLimits.laser.current}/${gameState.buildingLimits.laser.max}`;
            }
            if (elements.missileLimit) {
                elements.missileLimit.textContent = `${gameState.buildingLimits.missile.current}/${gameState.buildingLimits.missile.max}`;
            }
            if (elements.slowTowerLimit) {
                elements.slowTowerLimit.textContent = `${gameState.buildingLimits['slow-tower'].current}/${gameState.buildingLimits['slow-tower'].max}`;
            }
            if (elements.barracksLimit) {
                elements.barracksLimit.textContent = `${gameState.buildingLimits.barracks.current}/${gameState.buildingLimits.barracks.max}`;
            }
        }

        // Start preparation phase
        function startPreparationPhase() {
            gameState.isPreparationPhase = true;
            elements.waveTimer.style.display = 'block';
            
            let timer = gameState.preparationTime;
            elements.timerDisplay.textContent = timer;
            
            const countdown = setInterval(() => {
                timer--;
                elements.timerDisplay.textContent = timer;
                
                if (timer <= 0) {
                    clearInterval(countdown);
                    startWave();
                }
            }, 1000);
        }

        // Start a new wave
        function startWave() {
            gameState.isPreparationPhase = false;
            elements.waveTimer.style.display = 'none';
            gameState.wave++;
            updateDisplays();
            
            // Spawn enemies (1.1x more each wave)
            const enemyCount = Math.floor(5 * Math.pow(1.3, gameState.wave));
            spawnEnemies(enemyCount);
        }

        // Spawn enemies
        function spawnEnemies(count) {
            const boardWidth = elements.gameBoard.clientWidth;
            const boardHeight = elements.gameBoard.clientHeight;
            
            // Calculate enemy HP based on wave
            let enemyHP = gameState.enemyStats.baseHP * Math.pow(gameState.enemyStats.hpMultiplier, Math.floor(gameState.wave / gameState.enemyStats.hpIncreaseWaveInterval));
            
            for (let i = 0; i < count; i++) {
                const spawnPoint = gameState.enemySpawnPoints[
                    Math.floor(Math.random() * gameState.enemySpawnPoints.length)
                ];
                
                let x, y;
                if (spawnPoint.x === 0) {
                    x = Math.random() * 100;
                } else if (spawnPoint.x === 0.5) {
                    x = boardWidth / 2 + (Math.random() * 200 - 100);
                } else {
                    x = boardWidth - Math.random() * 100;
                }
                
                if (spawnPoint.y === 0) {
                    y = Math.random() * 100;
                } else if (spawnPoint.y === 0.5) {
                    y = boardHeight / 2 + (Math.random() * 200 - 100);
                } else {
                    y = boardHeight - Math.random() * 100;
                }
                
                // Random enemy type (more types in later waves)
                const enemyTypeIndex = Math.min(
                    Math.floor(Math.random() * (3 + Math.floor(gameState.wave / 5))),
                    gameState.enemyStats.types.length - 1
                );
                const enemyType = gameState.enemyStats.types[enemyTypeIndex];
                
                const enemy = document.createElement('div');
                enemy.className = `enemy ${enemyType.class}`;
                enemy.style.left = `${x}px`;
                enemy.style.top = `${y}px`;
                
                const healthBar = document.createElement('div');
                healthBar.className = 'enemy-health';
                
                const healthFill = document.createElement('div');
                healthFill.className = 'enemy-health-fill';
                healthFill.style.width = '100%';
                
                healthBar.appendChild(healthFill);
                enemy.appendChild(healthBar);
                elements.gameBoard.appendChild(enemy);
                
                gameState.enemies.push({
                    element: enemy,
                    x,
                    y,
                    hp: enemyHP,
                    maxHP: enemyHP,
                    speed: gameState.enemyStats.speed,
                    damage: gameState.enemyStats.damage,
                    healthFill,
                    isStunned: false,
                    stunTimer: 0,
                    isSlowed: false,
                    slowTimer: 0,
                    originalSpeed: gameState.enemyStats.speed
                });
            }
        }

        // Spawn minerals
        function spawnMinerals(count) {
            const boardWidth = elements.gameBoard.clientWidth;
            const boardHeight = elements.gameBoard.clientHeight;
            
            for (let i = 0; i < count; i++) {
                const x = 50 + Math.random() * (boardWidth - 100);
                const y = 50 + Math.random() * (boardHeight - 100);
                
                const mineral = document.createElement('div');
                mineral.className = 'mineral';
                mineral.style.left = `${x}px`;
                mineral.style.top = `${y}px`;
                elements.gameBoard.appendChild(mineral);
                
                gameState.minerals.push({
                    element: mineral,
                    x,
                    y
                });
            }
        }

        // Place building
        function placeBuilding(type, x, y) {
            const stats = gameState.buildingStats[type];
            
            // Check if player has enough money
            if (gameState.money < stats.cost) {
                return false;
            }
            
            // Check building limit
            if (gameState.buildingLimits[type].current >= gameState.buildingLimits[type].max) {
                return false;
            }
            
            // Check if position is valid (not on base and not overlapping other buildings)
            const baseRect = elements.base.getBoundingClientRect();
            const boardRect = elements.gameBoard.getBoundingClientRect();
            
            const baseX = baseRect.left - boardRect.left + baseRect.width / 2;
            const baseY = baseRect.top - boardRect.top + baseRect.height / 2;
            
            const distanceToBase = Math.sqrt(Math.pow(x - baseX, 2) + Math.pow(y - baseY, 2));
            if (distanceToBase < 60) {
                return false;
            }
            
            // Check for overlapping buildings
            for (const building of gameState.buildings) {
                const buildingX = parseInt(building.element.style.left);
                const buildingY = parseInt(building.element.style.top);
                const distance = Math.sqrt(Math.pow(x - buildingX, 2) + Math.pow(y - buildingY, 2));
                
                if (distance < 30) {
                    return false;
                }
            }
            
            // Snap to grid
            const gridSize = 40;
            const snappedX = Math.round(x / gridSize) * gridSize;
            const snappedY = Math.round(y / gridSize) * gridSize;
            
            // Create building
            const building = document.createElement('div');
            building.className = `building ${type}`;
            building.style.left = `${snappedX}px`;
            building.style.top = `${snappedY}px`;
            building.style.width = `${stats.size}px`;
            building.style.height = `${stats.size}px`;
            
            const levelDisplay = document.createElement('div');
            levelDisplay.className = 'building-level';
            levelDisplay.textContent = '1';
            building.appendChild(levelDisplay);
            
            const healthBar = document.createElement('div');
            healthBar.className = 'health-bar';
            
            const healthFill = document.createElement('div');
            healthFill.className = 'health-fill';
            healthFill.style.width = '100%';
            
            healthBar.appendChild(healthFill);
            building.appendChild(healthBar);
            
            const upgradeIndicator = document.createElement('div');
            upgradeIndicator.className = 'upgrade-indicator';
            upgradeIndicator.textContent = '‚Üë';
            building.appendChild(upgradeIndicator);
            
            elements.gameBoard.appendChild(building);
            
            // Add building to game state
            const newBuilding = {
                type,
                element: building,
                x: snappedX,
                y: snappedY,
                level: 1,
                hp: stats.hp,
                maxHP: stats.hp,
                healthFill,
                lastAttackTime: 0,
                // Type-specific properties
                ...(type === 'miner' ? {
                    lastProductionTime: 0,
                    productionRate: stats.baseProduction,
                    nearbyMinerals: []
                } : {}),
                ...(type === 'cannon' ? {
                    damage: stats.baseDamage,
                    attackSpeed: stats.baseAttackSpeed,
                    range: stats.range
                } : {}),
                ...(type === 'wall' ? {} : {}),
                ...(type === 'laser' ? {
                    damage: stats.baseDamage,
                    attackSpeed: stats.baseAttackSpeed,
                    range: stats.range,
                    stunDuration: stats.stunDuration,
                    chainTargets: stats.chainTargets
                } : {}),
                ...(type === 'missile' ? {
                    damage: stats.baseDamage,
                    attackSpeed: stats.baseAttackSpeed,
                    range: stats.range,
                    splashRadius: stats.splashRadius
                } : {}),
                ...(type === 'slow-tower' ? {
                    slowAmount: stats.slowAmount,
                    slowRadius: stats.slowRadius,
                    duration: stats.duration
                } : {}),
                ...(type === 'barracks' ? {
                    spawnRate: stats.spawnRate,
                    spawnAmount: stats.spawnAmount,
                    unitDamage: stats.unitDamage,
                    unitHP: stats.unitHP,
                    lastSpawnTime: 0
                } : {})
            };
            
            gameState.buildings.push(newBuilding);
            gameState.buildingLimits[type].current++;
            updateBuildingLimitsDisplay();
            
            // Deduct cost
            gameState.money -= stats.cost;
            updateDisplays();
            
            // Play sound
            gameState.sounds.build.currentTime = 0;
            gameState.sounds.build.play();
            
            // Set up event listeners
            building.addEventListener('click', (e) => {
                e.stopPropagation();
                upgradeBuilding(newBuilding);
            });
            
            building.addEventListener('mouseenter', () => showTooltip(newBuilding));
            building.addEventListener('mouseleave', hideTooltip);
            
            return true;
        }

        // Upgrade building
        function upgradeBuilding(building) {
            // Check if building can be upgraded further (based on base level)
            if (building.level >= gameState.baseLevel) {
                return;
            }
            
            const stats = gameState.buildingStats[building.type];
            const upgradeCost = Math.floor(stats.upgradeCost * Math.pow(stats.upgradeCostMultiplier, building.level - 1));
            
            if (gameState.money >= upgradeCost) {
                gameState.money -= upgradeCost;
                building.level++;
                building.element.querySelector('.building-level').textContent = building.level;
                
                // Update building properties based on type
                switch (building.type) {
                    case 'miner':
                        building.productionRate *= stats.productionMultiplier; // 1.7x
                        break;
                    case 'cannon':
                        building.damage *= stats.damageMultiplier;
                        building.attackSpeed /= stats.attackSpeedMultiplier;
                        break;
                    case 'wall':
                        building.maxHP *= stats.hpMultiplier;
                        building.hp = building.maxHP;
                        building.healthFill.style.width = '100%';
                        break;
                    case 'laser':
                        building.damage *= stats.damageMultiplier;
                        building.attackSpeed /= stats.attackSpeedMultiplier;
                        break;
                    case 'missile':
                        building.damage *= stats.damageMultiplier;
                        building.attackSpeed /= stats.attackSpeedMultiplier;
                        break;
                    case 'slow-tower':
                        building.slowAmount *= 1.1; // Slow effect increases
                        building.slowRadius *= 1.1; // Radius increases
                        break;
                    case 'barracks':
                        building.spawnAmount += 1; // Spawn more units
                        building.unitDamage *= 1.2;
                        building.unitHP *= 1.2;
                        break;
                }
                
                // Increase HP for all buildings
                building.maxHP *= 1.1;
                building.hp = building.maxHP;
                building.healthFill.style.width = '100%';
                
                // Play sound
                gameState.sounds.upgrade.currentTime = 0;
                gameState.sounds.upgrade.play();
                
                updateDisplays();
                showTooltip(building);
                
                // Visual feedback
                building.element.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    building.element.style.transform = 'scale(1)';
                }, 300);
            }
        }

        // Upgrade base
        function upgradeBase() {
            if (gameState.money >= gameState.baseUpgradeCost) {
                gameState.money -= gameState.baseUpgradeCost;
                gameState.baseLevel++;
                gameState.baseUpgradeCost = Math.floor(gameState.baseUpgradeCost * 1.5);
                
                // Increase base HP
                gameState.maxBaseHP *= 1.2;
                gameState.baseHP = gameState.maxBaseHP;
                
                // Update building limits based on base level
                // A cada 3 n√≠veis: +1 mineradora, +2 canh√µes, +3 muros
                if (gameState.baseLevel % 3 === 0) {
                    gameState.buildingLimits.miner.max += 1;
                    gameState.buildingLimits.cannon.max += 2;
                    gameState.buildingLimits.wall.max += 3;
                }
                
                // A partir do level 7, a cada 3 n√≠veis: +1 torre laser
                if (gameState.baseLevel >= 7 && gameState.baseLevel % 3 === 1) {
                    gameState.buildingLimits.laser.max += 1;
                }
                
                // Desbloqueios por n√≠vel
                if (gameState.baseLevel >= 15) {
                    gameState.buildingLimits['slow-tower'].max = 1;
                    document.querySelector('.build-option[data-type="slow-tower"]').classList.remove('disabled');
                }
                
                if (gameState.baseLevel >= 10) {
                    gameState.buildingLimits.missile.max = 3;
                    document.querySelector('.build-option[data-type="missile"]').classList.remove('disabled');
                }
                
                if (gameState.baseLevel >= 7) {
                    gameState.buildingLimits.laser.max += 1;
                    document.querySelector('.build-option[data-type="laser"]').classList.remove('disabled');
                }
                
                if (gameState.baseLevel >= 100) {
                    gameState.buildingLimits.barracks.max = 1;
                    document.querySelector('.build-option[data-type="barracks"]').classList.remove('disabled');
                }
                
                updateBuildingLimitsDisplay();
                updateDisplays();
                
                // Play sound
                gameState.sounds.baseUpgrade.currentTime = 0;
                gameState.sounds.baseUpgrade.play();
                
                // Visual feedback
                elements.base.style.transform = 'translate(-50%, -50%) scale(1.2)';
                setTimeout(() => {
                    elements.base.style.transform = 'translate(-50%, -50%) scale(1)';
                }, 300);
            }
        }

        // Show tooltip for building
        function showTooltip(building) {
            const stats = gameState.buildingStats[building.type];
            const upgradeCost = Math.floor(stats.upgradeCost * Math.pow(stats.upgradeCostMultiplier, building.level - 1));
            
            let tooltipText = `<h3>${stats.name} (N√≠vel ${building.level})</h3>`;
            tooltipText += `<p><strong>HP:</strong> ${Math.floor(building.hp)}/${Math.floor(building.maxHP)}</p>`;
            
            if (building.level < gameState.baseLevel) {
                tooltipText += `<p><strong>Upgrade:</strong> ${upgradeCost} diamantes (N√≠vel ${building.level + 1})</p>`;
            } else {
                tooltipText += `<p><strong>Upgrade:</strong> Melhore sua base para n√≠vel ${gameState.baseLevel + 1} primeiro</p>`;
            }
            
            switch (building.type) {
                case 'miner':
                    tooltipText += `<p><strong>Produ√ß√£o:</strong> ${building.productionRate.toFixed(1)} diamantes/s</p>`;
                    break;
                case 'cannon':
                    tooltipText += `<p><strong>Dano:</strong> ${building.damage.toFixed(1)}</p>`;
                    tooltipText += `<p><strong>Velocidade:</strong> ${(1 / building.attackSpeed).toFixed(1)} ataques/s</p>`;
                    tooltipText += `<p><strong>Alcance:</strong> ${building.range}px</p>`;
                    break;
                case 'wall':
                    tooltipText += `<p><strong>Defesa:</strong> ${building.maxHP.toFixed(0)} HP</p>`;
                    break;
                case 'laser':
                    tooltipText += `<p><strong>Dano:</strong> ${building.damage.toFixed(1)}</p>`;
                    tooltipText += `<p><strong>Velocidade:</strong> ${(1 / building.attackSpeed).toFixed(1)} ataques/s</p>`;
                    tooltipText += `<p><strong>Alcance:</strong> ${building.range}px</p>`;
                    tooltipText += `<p><strong>Atordoa:</strong> ${building.stunDuration}s</p>`;
                    tooltipText += `<p><strong>Alvos:</strong> ${building.chainTargets}</p>`;
                    break;
                case 'missile':
                    tooltipText += `<p><strong>Dano:</strong> ${building.damage.toFixed(1)}</p>`;
                    tooltipText += `<p><strong>Velocidade:</strong> ${(1 / building.attackSpeed).toFixed(1)} ataques/s</p>`;
                    tooltipText += `<p><strong>Alcance:</strong> ${building.range}px</p>`;
                    tooltipText += `<p><strong>Raio de explos√£o:</strong> ${building.splashRadius}px</p>`;
                    break;
                case 'slow-tower':
                    tooltipText += `<p><strong>Redu√ß√£o de velocidade:</strong> ${(building.slowAmount * 100).toFixed(0)}%</p>`;
                    tooltipText += `<p><strong>Raio de efeito:</strong> ${building.slowRadius.toFixed(0)}px</p>`;
                    tooltipText += `<p><strong>Dura√ß√£o:</strong> ${building.duration}s</p>`;
                    break;
                case 'barracks':
                    tooltipText += `<p><strong>Unidades:</strong> ${building.spawnAmount}</p>`;
                    tooltipText += `<p><strong>Taxa de spawn:</strong> 1 a cada ${building.spawnRate}s</p>`;
                    tooltipText += `<p><strong>Dano da unidade:</strong> ${building.unitDamage.toFixed(1)}</p>`;
                    tooltipText += `<p><strong>HP da unidade:</strong> ${building.unitHP.toFixed(0)}</p>`;
                    break;
            }
            
            tooltipText += `<p><em>Clique para melhorar</em></p>`;
            
            elements.tooltip.innerHTML = tooltipText;
            elements.tooltip.style.display = 'block';
            
            // Position tooltip near building
            const rect = building.element.getBoundingClientRect();
            elements.tooltip.style.left = `${rect.right + 5}px`;
            elements.tooltip.style.top = `${rect.top}px`;
        }

        // Show tooltip for base
        function showBaseTooltip() {
            const upgradeCost = gameState.baseUpgradeCost;
            const nextLevel = gameState.baseLevel + 1;
            
            let tooltipText = `<h3>Base (N√≠vel ${gameState.baseLevel})</h3>`;
            tooltipText += `<p><strong>HP:</strong> ${gameState.baseHP}/${gameState.maxBaseHP}</p>`;
            
            if (gameState.baseLevel < 100) {
                tooltipText += `<p><strong>Upgrade para n√≠vel ${nextLevel}:</strong> ${upgradeCost} diamantes</p>`;
                
                // Show benefits of next level
                tooltipText += `<p><strong>Benef√≠cios:</strong></p>`;
                tooltipText += `<ul>`;
                tooltipText += `<li>+10% HP da base</li>`;
                
                if (nextLevel % 3 === 0) {
                    tooltipText += `<li>+1 Mineradora</li>`;
                    tooltipText += `<li>+2 Canh√µes</li>`;
                    tooltipText += `<li>+3 Muros</li>`;
                }
                
                if (nextLevel >= 7 && nextLevel % 3 === 1) {
                    tooltipText += `<li>+1 Torre Laser</li>`;
                }
                
                if (nextLevel === 15) {
                    tooltipText += `<li>Desbloqueia Torre de Gelo</li>`;
                }
                
                if (nextLevel === 10) {
                    tooltipText += `<li>Desbloqueia Lan√ßador de M√≠sseis</li>`;
                }
                
                if (nextLevel === 7) {
                    tooltipText += `<li>Desbloqueia Torre Laser</li>`;
                }
                
                if (nextLevel === 100) {
                    tooltipText += `<li>Desbloqueia Quartel</li>`;
                }
                
                tooltipText += `<li>Permite upgrades at√© n√≠vel ${nextLevel}</li>`;
                tooltipText += `</ul>`;
            } else {
                tooltipText += `<p><strong>N√≠vel m√°ximo alcan√ßado!</strong></p>`;
            }
            
            elements.tooltip.innerHTML = tooltipText;
            elements.tooltip.style.display = 'block';
            
            // Position tooltip near base
            const rect = elements.base.getBoundingClientRect();
            elements.tooltip.style.left = `${rect.right + 5}px`;
            elements.tooltip.style.top = `${rect.top}px`;
        }

        // Hide tooltip
        function hideTooltip() {
            elements.tooltip.style.display = 'none';
        }

        // Game loop
        function gameLoop(timestamp) {
            if (gameState.gameOver) return;
            
            // Update buildings
            updateBuildings(timestamp);
            
            // Update enemies
            updateEnemies(timestamp);
            
            // Update projectiles
            updateProjectiles();
            
            // Update laser beams
            updateLaserBeams();
            
            // Update missile trails
            updateMissileTrails();
            
            // Update slow fields
            updateSlowFields(timestamp);
            
            // Check if wave is complete
            if (!gameState.isPreparationPhase && gameState.enemies.length === 0) {
                startPreparationPhase();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Update buildings
        function updateBuildings(timestamp) {
            for (let i = gameState.buildings.length - 1; i >= 0; i--) {
                const building = gameState.buildings[i];
                
                // Check if building is destroyed
                if (building.hp <= 0) {
                    building.element.remove();
                    gameState.buildings.splice(i, 1);
                    gameState.buildingLimits[building.type].current--;
                    updateBuildingLimitsDisplay();
                    continue;
                }
                
                // Update health bar
                const healthPercent = (building.hp / building.maxHP) * 100;
                building.healthFill.style.width = `${healthPercent}%`;
                
                // Building type-specific updates
                switch (building.type) {
                    case 'miner':
                        updateMiner(building, timestamp);
                        break;
                    case 'cannon':
                        updateCannon(building, timestamp);
                        break;
                    case 'laser':
                        updateLaser(building, timestamp);
                        break;
                    case 'missile':
                        updateMissile(building, timestamp);
                        break;
                    case 'slow-tower':
                        updateSlowTower(building, timestamp);
                        break;
                    case 'barracks':
                        updateBarracks(building, timestamp);
                        break;
                }
            }
        }

        // Update miner building
        function updateMiner(building, timestamp) {
            // Find nearby minerals
            if (building.nearbyMinerals.length === 0) {
                for (const mineral of gameState.minerals) {
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.element.clientWidth / 2 - mineral.x, 2) +
                        Math.pow(building.y + building.element.clientHeight / 2 - mineral.y, 2)
                    );
                    
                    if (distance < 100) {
                        building.nearbyMinerals.push(mineral);
                    }
                }
            }
            
            // Produce money if near minerals
            if (building.nearbyMinerals.length > 0 && timestamp - building.lastProductionTime > 1000) {
                gameState.money += building.productionRate;
                updateDisplays();
                building.lastProductionTime = timestamp;
                
                // Visual feedback
                building.element.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    building.element.style.transform = 'scale(1)';
                }, 100);
            }
        }

        // Update cannon building
        function updateCannon(building, timestamp) {
            if (timestamp - building.lastAttackTime > building.attackSpeed * 1000) {
                // Find closest enemy in range
                let closestEnemy = null;
                let closestDistance = Infinity;
                
                for (const enemy of gameState.enemies) {
                    if (enemy.isStunned) continue;
                    
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.element.clientWidth / 2 - enemy.x, 2) +
                        Math.pow(building.y + building.element.clientHeight / 2 - enemy.y, 2)
                    );
                    
                    if (distance < building.range && distance < closestDistance) {
                        closestEnemy = enemy;
                        closestDistance = distance;
                    }
                }
                
                // Attack if enemy found
                if (closestEnemy) {
                    building.lastAttackTime = timestamp;
                    
                    // Create projectile
                    const projectile = document.createElement('div');
                    projectile.className = 'projectile';
                    projectile.style.left = `${building.x + building.element.clientWidth / 2 - 5}px`;
                    projectile.style.top = `${building.y + building.element.clientHeight / 2 - 5}px`;
                    elements.gameBoard.appendChild(projectile);
                    
                    gameState.projectiles.push({
                        element: projectile,
                        startX: building.x + building.element.clientWidth / 2,
                        startY: building.y + building.element.clientHeight / 2,
                        targetX: closestEnemy.x + closestEnemy.element.clientWidth / 2,
                        targetY: closestEnemy.y + closestEnemy.element.clientHeight / 2,
                        speed: 500, // pixels per second
                        damage: building.damage,
                        target: closestEnemy
                    });
                    
                    // Play sound
                    gameState.sounds.attack.currentTime = 0;
                    gameState.sounds.attack.play();
                    
                    // Visual feedback
                    building.element.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        building.element.style.transform = 'scale(1)';
                    }, 100);
                }
            }
        }

        // Update laser tower
        function updateLaser(building, timestamp) {
            if (timestamp - building.lastAttackTime > building.attackSpeed * 1000) {
                // Find enemies in range
                const enemiesInRange = [];
                
                for (const enemy of gameState.enemies) {
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.element.clientWidth / 2 - enemy.x, 2) +
                        Math.pow(building.y + building.element.clientHeight / 2 - enemy.y, 2)
                    );
                    
                    if (distance < building.range) {
                        enemiesInRange.push({ enemy, distance });
                    }
                }
                
                // Sort by distance
                enemiesInRange.sort((a, b) => a.distance - b.distance);
                
                // Attack if enemies found (up to chain limit)
                if (enemiesInRange.length > 0) {
                    building.lastAttackTime = timestamp;
                    
                    const targets = enemiesInRange.slice(0, building.chainTargets);
                    
                    // Create laser beam
                    const beam = document.createElement('div');
                    beam.className = 'laser-beam';
                    elements.gameBoard.appendChild(beam);
                    
                    gameState.laserBeams.push({
                        element: beam,
                        source: building,
                        targets,
                        damage: building.damage,
                        stunDuration: building.stunDuration,
                        startTime: timestamp,
                        duration: 300 // milliseconds
                    });
                    
                    // Play sound
                    gameState.sounds.laser.currentTime = 0;
                    gameState.sounds.laser.play();
                    
                    // Apply damage and stun
                    for (const target of targets) {
                        target.enemy.hp -= building.damage;
                        target.enemy.healthFill.style.width = `${(target.enemy.hp / target.enemy.maxHP) * 100}%`;
                        
                        // Stun enemy
                        target.enemy.isStunned = true;
                        target.enemy.stunTimer = timestamp + building.stunDuration * 1000;
                        
                        // Visual feedback
                        target.enemy.element.style.backgroundColor = '#00ffff';
                        setTimeout(() => {
                            if (target.enemy.stunTimer <= timestamp) {
                                target.enemy.element.style.backgroundColor = '';
                            }
                        }, building.stunDuration * 1000);
                    }
                    
                    // Visual feedback
                    building.element.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        building.element.style.transform = 'scale(1)';
                    }, 100);
                }
            }
        }

        // Update missile launcher
        function updateMissile(building, timestamp) {
            if (timestamp - building.lastAttackTime > building.attackSpeed * 1000) {
                // Find enemy with most health in range
                let targetEnemy = null;
                let maxHealth = 0;
                
                for (const enemy of gameState.enemies) {
                    const distance = Math.sqrt(
                        Math.pow(building.x + building.element.clientWidth / 2 - enemy.x, 2) +
                        Math.pow(building.y + building.element.clientHeight / 2 - enemy.y, 2)
                    );
                    
                    if (distance < building.range && enemy.hp > maxHealth) {
                        targetEnemy = enemy;
                        maxHealth = enemy.hp;
                    }
                }
                
                // Attack if enemy found
                if (targetEnemy) {
                    building.lastAttackTime = timestamp;
                    
                    // Create missile trail
                    const trail = document.createElement('div');
                    trail.className = 'missile-trail';
                    elements.gameBoard.appendChild(trail);
                    
                    gameState.missileTrails.push({
                        element: trail,
                        startX: building.x + building.element.clientWidth / 2,
                        startY: building.y + building.element.clientHeight / 2,
                        targetX: targetEnemy.x + targetEnemy.element.clientWidth / 2,
                        targetY: targetEnemy.y + targetEnemy.element.clientHeight / 2,
                        speed: 300, // pixels per second
                        damage: building.damage,
                        splashRadius: building.splashRadius,
                        target: targetEnemy,
                        startTime: timestamp
                    });
                    
                    // Play sound
                    gameState.sounds.missile.currentTime = 0;
                    gameState.sounds.missile.play();
                    
                    // Visual feedback
                    building.element.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        building.element.style.transform = 'scale(1)';
                    }, 100);
                }
            }
        }

        // Update slow tower
        function updateSlowTower(building, timestamp) {
            // Create slow field around tower
            const slowField = document.createElement('div');
            slowField.className = 'slow-field';
            slowField.style.left = `${building.x + building.element.clientWidth / 2 - building.slowRadius}px`;
            slowField.style.top = `${building.y + building.element.clientHeight / 2 - building.slowRadius}px`;
            slowField.style.width = `${building.slowRadius * 2}px`;
            slowField.style.height = `${building.slowRadius * 2}px`;
            elements.gameBoard.appendChild(slowField);
            
            gameState.slowFields.push({
                element: slowField,
                x: building.x + building.element.clientWidth / 2,
                y: building.y + building.element.clientHeight / 2,
                radius: building.slowRadius,
                slowAmount: building.slowAmount,
                duration: building.duration,
                startTime: timestamp
            });
            
            // Play sound (only once when first created)
            if (gameState.slowFields.length === 1) {
                gameState.sounds.slow.currentTime = 0;
                gameState.sounds.slow.play();
            }
        }

        // Update barracks
        function updateBarracks(building, timestamp) {
            if (timestamp - building.lastSpawnTime > building.spawnRate * 1000) {
                building.lastSpawnTime = timestamp;
                
                // Spawn units
                for (let i = 0; i < building.spawnAmount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50 + Math.random() * 20;
                    
                    const unitX = building.x + building.element.clientWidth / 2 + Math.cos(angle) * distance;
                    const unitY = building.y + building.element.clientHeight / 2 + Math.sin(angle) * distance;
                    
                    const unit = document.createElement('div');
                    unit.className = 'enemy enemy-type4'; // Usando classe de inimigo como base
                    unit.style.left = `${unitX}px`;
                    unit.style.top = `${unitY}px`;
                    
                    const healthBar = document.createElement('div');
                    healthBar.className = 'enemy-health';
                    
                    const healthFill = document.createElement('div');
                    healthFill.className = 'enemy-health-fill';
                    healthFill.style.width = '100%';
                    
                    healthBar.appendChild(healthFill);
                    unit.appendChild(healthBar);
                    elements.gameBoard.appendChild(unit);
                    
                    // Adiciona como aliado (n√£o ataca a base)
                    gameState.enemies.push({
                        element: unit,
                        x: unitX,
                        y: unitY,
                        hp: building.unitHP,
                        maxHP: building.unitHP,
                        speed: 40,
                        damage: building.unitDamage,
                        healthFill,
                        isAlly: true // Marca como aliado
                    });
                }
                
                // Play sound
                gameState.sounds.barracks.currentTime = 0;
                gameState.sounds.barracks.play();
                
                // Visual feedback
                building.element.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    building.element.style.transform = 'scale(1)';
                }, 100);
            }
        }

        // Update enemies
        function updateEnemies(timestamp) {
            const baseRect = elements.base.getBoundingClientRect();
            const boardRect = elements.gameBoard.getBoundingClientRect();
            
            const baseX = baseRect.left - boardRect.left + baseRect.width / 2;
            const baseY = baseRect.top - boardRect.top + baseRect.height / 2;
            
            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const enemy = gameState.enemies[i];
                
                // Skip if this is an ally (from barracks)
                if (enemy.isAlly) {
                    // Ally behavior: attack closest enemy
                    let closestEnemy = null;
                    let closestDistance = Infinity;
                    
                    for (const otherEnemy of gameState.enemies) {
                        if (otherEnemy.isAlly || otherEnemy === enemy) continue;
                        
                        const distance = Math.sqrt(
                            Math.pow(enemy.x - otherEnemy.x, 2) +
                            Math.pow(enemy.y - otherEnemy.y, 2)
                        );
                        
                        if (distance < 50 && distance < closestDistance) {
                            closestEnemy = otherEnemy;
                            closestDistance = distance;
                        }
                    }
                    
                    // Attack if enemy found
                    if (closestEnemy && closestDistance < 30) {
                        closestEnemy.hp -= enemy.damage;
                        closestEnemy.healthFill.style.width = `${(closestEnemy.hp / closestEnemy.maxHP) * 100}%`;
                        
                        // Visual feedback
                        enemy.element.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            enemy.element.style.transform = 'scale(1)';
                        }, 100);
                        
                        // Check if enemy is dead
                        if (closestEnemy.hp <= 0) {
                            closestEnemy.element.remove();
                            gameState.enemies.splice(gameState.enemies.indexOf(closestEnemy), 1);
                        }
                    } else if (closestEnemy) {
                        // Move toward enemy
                        const angle = Math.atan2(closestEnemy.y - enemy.y, closestEnemy.x - enemy.x);
                        enemy.x += Math.cos(angle) * (enemy.speed / 60);
                        enemy.y += Math.sin(angle) * (enemy.speed / 60);
                        enemy.element.style.left = `${enemy.x}px`;
                        enemy.element.style.top = `${enemy.y}px`;
                    }
                    
                    continue;
                }
                
                // Check if enemy is dead
                if (enemy.hp <= 0) {
                    // Chance to drop mineral
                    if (Math.random() < 0.3) {
                        const mineral = document.createElement('div');
                        mineral.className = 'mineral';
                        mineral.style.left = `${enemy.x}px`;
                        mineral.style.top = `${enemy.y}px`;
                        elements.gameBoard.appendChild(mineral);
                        
                        gameState.minerals.push({
                            element: mineral,
                            x: enemy.x,
                            y: enemy.y
                        });
                    }
                    
                    // Play sound
                    gameState.sounds.enemyDeath.currentTime = 0;
                    gameState.sounds.enemyDeath.play();
                    
                    enemy.element.remove();
                    gameState.enemies.splice(i, 1);
                    continue;
                }
                
                // Check if enemy is stunned
                if (enemy.isStunned) {
                    if (timestamp >= enemy.stunTimer) {
                        enemy.isStunned = false;
                        enemy.element.style.backgroundColor = '';
                    }
                    continue;
                }
                
                // Check if enemy is slowed
                if (enemy.isSlowed) {
                    if (timestamp >= enemy.slowTimer) {
                        enemy.isSlowed = false;
                        enemy.speed = enemy.originalSpeed;
                        enemy.element.style.filter = '';
                    }
                }
                
                // Move toward base
                const angle = Math.atan2(baseY - enemy.y, baseX - enemy.x);
                const speed = enemy.speed / 60; // Assuming 60 FPS
                
                enemy.x += Math.cos(angle) * speed;
                enemy.y += Math.sin(angle) * speed;
                
                enemy.element.style.left = `${enemy.x}px`;
                enemy.element.style.top = `${enemy.y}px`;
                
                // Check collision with ALL buildings (n√£o apenas muros)
                for (const building of gameState.buildings) {
                    const buildingCenterX = building.x + building.element.clientWidth / 2;
                    const buildingCenterY = building.y + building.element.clientHeight / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(enemy.x - buildingCenterX, 2) +
                        Math.pow(enemy.y - buildingCenterY, 2)
                    );
                    
                    // Colis√£o com qualquer constru√ß√£o
                    if (distance < 30) {
                        // Damage building
                        building.hp -= enemy.damage;
                        
                        // Visual feedback
                        building.element.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            building.element.style.transform = 'scale(1)';
                        }, 100);
                        
                        // Move enemy back slightly
                        const pushAngle = Math.atan2(enemy.y - buildingCenterY, enemy.x - buildingCenterX);
                        enemy.x += Math.cos(pushAngle) * 5;
                        enemy.y += Math.sin(pushAngle) * 5;
                        
                        break; // S√≥ colide com uma constru√ß√£o por frame
                    }
                }
                
                // Check collision with base
                const distanceToBase = Math.sqrt(Math.pow(baseX - enemy.x, 2) + Math.pow(baseY - enemy.y, 2));
                if (distanceToBase < 40) {
                    // Damage base
                    gameState.baseHP -= enemy.damage;
                    elements.baseHpDisplay.textContent = gameState.baseHP;
                    
                    // Visual feedback
                    elements.base.style.transform = 'translate(-50%, -50%) scale(1.1)';
                    setTimeout(() => {
                        elements.base.style.transform = 'translate(-50%, -50%) scale(1)';
                    }, 100);
                    
                    // Remove enemy
                    enemy.element.remove();
                    gameState.enemies.splice(i, 1);
                    
                    // Check if base is destroyed
                    if (gameState.baseHP <= 0) {
                        gameOver();
                    }
                }
            }
        }

        // Update projectiles
        function updateProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                
                // Calculate direction
                const dx = projectile.targetX - projectile.startX;
                const dy = projectile.targetY - projectile.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const directionX = dx / distance;
                const directionY = dy / distance;
                
                // Move projectile
                const elapsed = 1/60; // Assuming 60 FPS
                const moveDistance = projectile.speed * elapsed;
                
                projectile.startX += directionX * moveDistance;
                projectile.startY += directionY * moveDistance;
                
                projectile.element.style.left = `${projectile.startX - 5}px`;
                projectile.element.style.top = `${projectile.startY - 5}px`;
                
                // Check if reached target or passed it
                const newDx = projectile.targetX - projectile.startX;
                const newDy = projectile.targetY - projectile.startY;
                const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);
                
                if (newDistance > distance || distance < 5) {
                    // Apply damage
                    if (gameState.enemies.includes(projectile.target)) {
                        projectile.target.hp -= projectile.damage;
                        projectile.target.healthFill.style.width = `${(projectile.target.hp / projectile.target.maxHP) * 100}%`;
                        
                        // Visual feedback
                        projectile.target.element.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            projectile.target.element.style.transform = 'scale(1)';
                        }, 100);
                    }
                    
                    // Remove projectile
                    projectile.element.remove();
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // Update laser beams
        function updateLaserBeams() {
            for (let i = gameState.laserBeams.length - 1; i >= 0; i--) {
                const beam = gameState.laserBeams[i];
                
                // Draw beam between source and targets
                let path = '';
                let lastX = beam.source.x + beam.source.element.clientWidth / 2;
                let lastY = beam.source.y + beam.source.element.clientHeight / 2;
                
                for (const target of beam.targets) {
                    const targetX = target.enemy.x + target.enemy.element.clientWidth / 2;
                    const targetY = target.enemy.y + target.enemy.element.clientHeight / 2;
                    
                    path += `M ${lastX} ${lastY} L ${targetX} ${targetY} `;
                    lastX = targetX;
                    lastY = targetY;
                }
                
                beam.element.setAttribute('d', path);
                beam.element.style.strokeWidth = '3px';
                
                // Check if beam duration is over
                if (performance.now() - beam.startTime > beam.duration) {
                    beam.element.remove();
                    gameState.laserBeams.splice(i, 1);
                }
            }
        }

        // Update missile trails
        function updateMissileTrails() {
            for (let i = gameState.missileTrails.length - 1; i >= 0; i--) {
                const missile = gameState.missileTrails[i];
                
                // Calculate direction
                const dx = missile.targetX - missile.startX;
                const dy = missile.targetY - missile.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const directionX = dx / distance;
                const directionY = dy / distance;
                
                // Move missile
                const elapsed = (performance.now() - missile.startTime) / 1000;
                const moveDistance = missile.speed * elapsed;
                
                const currentX = missile.startX + directionX * moveDistance;
                const currentY = missile.startY + directionY * moveDistance;
                
                // Update trail
                missile.element.setAttribute('d', `M ${missile.startX} ${missile.startY} L ${currentX} ${currentY}`);
                missile.element.style.strokeWidth = '2px';
                
                // Check if reached target or passed it
                const newDx = missile.targetX - currentX;
                const newDy = missile.targetY - currentY;
                const newDistance = Math.sqrt(newDx * newDx + newDy * newDy);
                
                if (newDistance > distance || distance < 5) {
                    // Apply splash damage
                    for (const enemy of gameState.enemies) {
                        const enemyDistance = Math.sqrt(
                            Math.pow(currentX - (enemy.x + enemy.element.clientWidth / 2), 2) +
                            Math.pow(currentY - (enemy.y + enemy.element.clientHeight / 2), 2)
                        );
                        
                        if (enemyDistance < missile.splashRadius) {
                            // Damage decreases with distance
                            const damage = missile.damage * (1 - enemyDistance / missile.splashRadius);
                            enemy.hp -= damage;
                            enemy.healthFill.style.width = `${(enemy.hp / enemy.maxHP) * 100}%`;
                            
                            // Visual feedback
                            enemy.element.style.transform = 'scale(1.1)';
                            setTimeout(() => {
                                enemy.element.style.transform = 'scale(1)';
                            }, 100);
                        }
                    }
                    
                    // Remove missile
                    missile.element.remove();
                    gameState.missileTrails.splice(i, 1);
                }
            }
        }

        // Update slow fields
        function updateSlowFields(timestamp) {
            for (let i = gameState.slowFields.length - 1; i >= 0; i--) {
                const field = gameState.slowFields[i];
                
                // Update field position and size (in case tower was moved)
                field.element.style.left = `${field.x - field.radius}px`;
                field.element.style.top = `${field.y - field.radius}px`;
                field.element.style.width = `${field.radius * 2}px`;
                field.element.style.height = `${field.radius * 2}px`;
                
                // Apply slow effect to enemies in range
                for (const enemy of gameState.enemies) {
                    const distance = Math.sqrt(
                        Math.pow(field.x - enemy.x, 2) +
                        Math.pow(field.y - enemy.y, 2)
                    );
                    
                    if (distance < field.radius) {
                        if (!enemy.isSlowed) {
                            enemy.isSlowed = true;
                            enemy.originalSpeed = enemy.speed;
                            enemy.speed = enemy.originalSpeed * (1 - field.slowAmount);
                            enemy.element.style.filter = 'hue-rotate(180deg)';
                        }
                        enemy.slowTimer = timestamp + field.duration * 1000;
                    }
                }
                
                // Remove field if duration is over
                if (performance.now() - field.startTime > field.duration * 1000) {
                    field.element.remove();
                    gameState.slowFields.splice(i, 1);
                }
            }
        }

        // Game over
        function gameOver() {
            gameState.gameOver = true;
            elements.finalWaveDisplay.textContent = gameState.wave;
            elements.gameOverScreen.style.display = 'flex';
            
            // Play sound
            gameState.sounds.gameOver.currentTime = 0;
            gameState.sounds.gameOver.play();
        }

        // Event listeners
        function setupEventListeners() {
            // Building selection
            elements.buildOptions.forEach(option => {
                option.addEventListener('click', () => {
                    elements.buildOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    
                    const type = option.dataset.type;
                    gameState.selectedBuilding = type;
                });
            });
            
            // Keyboard shortcuts for building selection
            document.addEventListener('keydown', (e) => {
                if (e.key >= '1' && e.key <= '7') {
                    const index = parseInt(e.key) - 1;
                    if (index < elements.buildOptions.length) {
                        elements.buildOptions.forEach(opt => opt.classList.remove('selected'));
                        elements.buildOptions[index].classList.add('selected');
                        gameState.selectedBuilding = elements.buildOptions[index].dataset.type;
                    }
                }
            });
            
            // Place building on click
            elements.gameBoard.addEventListener('click', (e) => {
                if (!gameState.selectedBuilding) return;
                
                const rect = elements.gameBoard.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                placeBuilding(gameState.selectedBuilding, x, y);
            });
            
            // Base upgrade
            elements.baseUpgradeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                upgradeBase();
            });
            
            // Base tooltip
            elements.base.addEventListener('mouseenter', showBaseTooltip);
            elements.base.addEventListener('mouseleave', hideTooltip);
            
            // Restart game
            elements.restartBtn.addEventListener('click', initGame);
            
            // Pan the game board with mouse drag
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;
            
            elements.gameBoard.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.ctrlKey)) { // Middle click or Ctrl+Left click
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - lastX;
                    const dy = e.clientY - lastY;
                    
                    elements.gameBoard.scrollLeft -= dx;
                    elements.gameBoard.scrollTop -= dy;
                    
                    lastX = e.clientX;
                    lastY = e.clientY;
                }
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Zoom with mouse wheel
            elements.gameBoard.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const wheelDelta = e.deltaY < 0 ? 1 : -1;
                
                // Get mouse position relative to game board
                const rect = elements.gameBoard.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Calculate scroll position before zoom
                const scrollX = elements.gameBoard.scrollLeft + mouseX;
                const scrollY = elements.gameBoard.scrollTop + mouseY;
                
               
                
                // Adjust scroll position to zoom at mouse position
                elements.gameBoard.scrollLeft = scrollX * zoomFactor - mouseX;
                elements.gameBoard.scrollTop = scrollY * zoomFactor - mouseY;
            });
        }

        // Initialize game
        setupEventListeners();
        initGame();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
